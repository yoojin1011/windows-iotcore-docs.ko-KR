---
title: AllJoynCodeGen 개요
author: saraclay
ms.author: saclayt
ms.date: 09/06/17
ms.topic: article
ms.prod: windows-iot
ms.technology: IoT
description: AllJoyn 인터페이스를 사용 하 여 완전 한 Windows 런타임 구성 요소를 생성 하는 코드 생성 도구인 AllJoynCodeGen에 대해 알아봅니다.
keywords: windows iot, AllJoyn
ms.openlocfilehash: c8e9f08c5565c7e4252e1b15858c08402eedb712
ms.sourcegitcommit: 2b4ce105834c294dcdd8f332ac8dd2732f4b5af8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "60167753"
---
> [!NOTE]
> <span data-ttu-id="aa813-104">보관 된 설명서를 보고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-104">You are viewing archived documentation.</span></span> <span data-ttu-id="aa813-105">AllJoyn는 Windows 10 IoT에서 더 이상 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-105">AllJoyn is no longer supported by Windows 10 IoT.</span></span> <span data-ttu-id="aa813-106">질문이 있는 경우 GitHub에서 문제를 열거나 아래 설명에 의견을 남겨 주세요.</span><span class="sxs-lookup"><span data-stu-id="aa813-106">For questions, please open an issue on GitHub or leave us feedback in the comments below.</span></span>

# <a name="alljoyncodegen-overview"></a><span data-ttu-id="aa813-107">AllJoynCodeGen 개요</span><span class="sxs-lookup"><span data-stu-id="aa813-107">AllJoynCodeGen Overview</span></span>

<span data-ttu-id="aa813-108">사양 또는 장치에서 파생 된 하나 이상의 AllJoyn 인터페이스에 대 한 XML 설명을 사용 하 여 전체 Windows 런타임 구성 요소를 생성 하는 코드 생성 도구인 AllJoynCodeGen를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-108">We've created a code generation tool, AllJoynCodeGen, that generates a complete Windows Runtime component using an XML description of one or more AllJoyn interfaces derived from a specification or device.</span></span>

<span data-ttu-id="aa813-109">이 도구에서 생성 된 Windows 런타임 구성 요소는 유니버설 Windows SDK에서 사용할 수 있는 api를 C#사용 C++하 여 지원 되는 모든 언어 (JS,,/cx 등)에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-109">The Windows Runtime component generated by this tool can be consumed in any supported language (JS, C#, C++/CX, etc.) using APIs that are available in the Universal Windows SDK.</span></span> <span data-ttu-id="aa813-110">즉, 동일한 구성 요소는 AllJoyn OneCore 패키지 (라우터 서비스 및 C API dll)를 포함 하는 모든 플랫폼에서 사용할 수 있습니다. 그런 다음 개발자는 구성 요소를 사용 하 여 해당 인터페이스의 생산자 및/또는 소비자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-110">This means that the same component can be used on any platform that has the AllJoyn OneCore package (router service and C API dll.) A developer can then use the component to create a producer and/or a consumer of that interface.</span></span> 

<span data-ttu-id="aa813-111">**참고**  AllJoyn C Api에 대 한 자세한 내용을 보려면 [AllSeen 동맹](http://go.microsoft.com/fwlink/?LinkId=524584)에서 ALLJOYN Core SDK 및 설명서를 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-111">**Note**  For more details about the AllJoyn C APIs, you can download the AllJoyn Core SDK and documentation at [The AllSeen Alliance](http://go.microsoft.com/fwlink/?LinkId=524584).</span></span>

## <a name="how-does-alljoyncodegen-work"></a><span data-ttu-id="aa813-112">AllJoynCodeGen는 어떻게 작동 하나요?</span><span class="sxs-lookup"><span data-stu-id="aa813-112">How does AllJoynCodeGen work?</span></span>

<span data-ttu-id="aa813-113">기본 흐름은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-113">The basic flow is as follows:</span></span>

1. <span data-ttu-id="aa813-114">서비스를 설명 하는 AllJoyn XML (현재는 Ebus 검사 형식)으로 작성 된 XML 파일은 codegen 도구에 공급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-114">An XML file authored in the AllJoyn XML (currently DBus introspection format) that describes the service is fed into the codegen tool.</span></span>
2. <span data-ttu-id="aa813-115">AllJoynCodeGen 도구는 Windows 런타임 구성 요소가 발생 하는 코드를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-115">The AllJoynCodeGen tool generates code that results in a Windows Runtime component.</span></span> <span data-ttu-id="aa813-116">이 생성 된 코드는 Windows 10 SDK의 **MSAJAPI** 및 [windows 기반 장치](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx) 를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-116">This generated code relies on **MSAJAPI.lib** and [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx) from the Windows 10 SDK.</span></span>
3. <span data-ttu-id="aa813-117">개발자는이 구성 요소를 사용 하는 응용 프로그램을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-117">The developer builds an application that consumes this component.</span></span>
4. <span data-ttu-id="aa813-118">런타임에 개발자 응용 프로그램은 도구에서 생성 된 Windows 런타임 구성 요소 (예: foo. dll) 뿐만 아니라 기본 Dll **MSAJAPI** 및 **Windows.** x x x. x x x. x x x. x x x. x x x. x x x. x x x. x x x.</span><span class="sxs-lookup"><span data-stu-id="aa813-118">At runtime, the developer's application will load the Windows Runtime component generated by the tool (e.g.: foo.dll,) as well as the in-box DLLs **MSAJAPI.dll** and **Windows.Devices.AllJoyn.dll**.</span></span>

<span data-ttu-id="aa813-119">다음 워크플로 다이어그램은이 프로세스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-119">The following workflow diagram illustrates this process:</span></span>

![AllJoyn CodeGen 다이어그램](../media/AllJoyn/alljoyncodegen.png)

## <a name="running-from-the-command-line"></a><span data-ttu-id="aa813-121">명령줄에서 실행</span><span class="sxs-lookup"><span data-stu-id="aa813-121">Running from the command line</span></span>

<span data-ttu-id="aa813-122">AllJoynCodeGen 도구는 현재 Windows 10 SDK와 함께 제공 되는 명령줄 도구로 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-122">The AllJoynCodeGen tool currently exists as a command line tool shipped with the Windows 10 SDK.</span></span> <span data-ttu-id="aa813-123">도구를 실행 하려면 다음 문자열을 사용 하 여 올바른 XML 파일을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-123">To run the tool pass a valid XML file using the following string:</span></span>

    AllJoynCodeGen –i Foo.xml –o c:\users\developer1\documents\Foo\

## <a name="reviewing-the-output"></a><span data-ttu-id="aa813-124">출력 검토</span><span class="sxs-lookup"><span data-stu-id="aa813-124">Reviewing the output</span></span>

<span data-ttu-id="aa813-125">생성 된 클래스는 핵심 C API에 의해 노출 되는 기능을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-125">The generated classes wrap functionality exposed by the Core C API.</span></span> <span data-ttu-id="aa813-126">생성 된 코드가 추상적 이기 때문에이는 일대일 매핑이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-126">Because the generated code is an abstraction, this is not a 1-to-1 mapping.</span></span> <span data-ttu-id="aa813-127">아래 표에서는 생성 된 각 C++ 코드 클래스로 래핑된 핵심 api를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-127">The table below shows which Core C++ APIs are wrapped by each generated code class.</span></span> <span data-ttu-id="aa813-128">다음은 테이블의 생성 된 이름에 사용 되는 자리 표시자입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-128">The following placeholders are used for generated names in the table:</span></span>

* <span data-ttu-id="aa813-129">`<Foo>`xml 파일에 정의 된 인터페이스의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-129">`<Foo>` is the name of the interface defined in the xml file</span></span>
* <span data-ttu-id="aa813-130">`<Signal>`xml 파일에서 가져온 신호의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-130">`<Signal>` is the name of a signal, taken from the xml file</span></span>
* <span data-ttu-id="aa813-131">`<Method>`xml 파일에서 가져온 메서드의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-131">`<Method>` is the name of a method, taken from the xml file</span></span>
* <span data-ttu-id="aa813-132">`<Property>`xml 파일에서 가져온 속성의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-132">`<Property>` is the name of a property, taken from the xml file</span></span>


> | <span data-ttu-id="aa813-133">Windows 런타임 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-133">Windows Runtime Class</span></span> |  | <span data-ttu-id="aa813-134">설명</span><span class="sxs-lookup"><span data-stu-id="aa813-134">Description</span></span> | <span data-ttu-id="aa813-135">핵심 C++ API</span><span class="sxs-lookup"><span data-stu-id="aa813-135">Core C++ API</span></span> |
> | ------------------------ | --- | --------- | ---------- |
> | <span data-ttu-id="aa813-136">`<Foo>`감시자</span><span class="sxs-lookup"><span data-stu-id="aa813-136">`<Foo>`Watcher</span></span> |  | <span data-ttu-id="aa813-137">대상 서비스를 보급 하는 생산자를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-137">Searches for producers that advertise the target service</span></span> | <span data-ttu-id="aa813-138">*Buslistener* 클래스; *Busattachment* 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-138">*BusListener* class; *BusAttachment* class</span></span> |
> | <span data-ttu-id="aa813-139">`<Foo>`JoinSessionResult</span><span class="sxs-lookup"><span data-stu-id="aa813-139">`<Foo>`JoinSessionResult</span></span> |  | <span data-ttu-id="aa813-140">세션에 대 한 성공 또는 실패를 보고 하 고, 조인이 `<Foo>Consumer` 성공 하면 세션에 대 한 인스턴스를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-140">Reports the success or failure of joining a session, and exposes a `<Foo>Consumer` instance for the session if the join was successful.</span></span> | <span data-ttu-id="aa813-141">*JoinSessionAsyncCB* 클래스 *Qstatus*</span><span class="sxs-lookup"><span data-stu-id="aa813-141">*JoinSessionAsyncCB* class; *QStatus*</span></span> |
> | <span data-ttu-id="aa813-142">`<Foo>`점에서</span><span class="sxs-lookup"><span data-stu-id="aa813-142">`<Foo>`Producer</span></span> |  | <span data-ttu-id="aa813-143">서비스를 보급 하 고 AllJoyn 이벤트에 대 한 처리기를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-143">Advertises a service and exposes handlers for AllJoyn events.</span></span> | <span data-ttu-id="aa813-144">*Busobject* 클래스; *Busattachment* 클래스; *인터페이스 설명* 클래스; *Sessionportlistener* 클래스; *Message* 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-144">*BusObject* class; *BusAttachment* class; *InterfaceDescription* class; *SessionPortListener* class; *Message* class</span></span> |
> | <span data-ttu-id="aa813-145">`<Foo>`연산</span><span class="sxs-lookup"><span data-stu-id="aa813-145">`<Foo>`Signals</span></span> |  | <span data-ttu-id="aa813-146">신호를 보내고 받는 메서드 및 처리기를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-146">Exposes methods and handlers to send and receive signals.</span></span> <span data-ttu-id="aa813-147">생산자와 소비자 모두에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-147">Used by both producers and consumers.</span></span> | <span data-ttu-id="aa813-148">*Busobject* 클래스; *인터페이스 설명* 클래스; *Message* 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-148">*BusObject* class; *InterfaceDescription* class; *Message* class</span></span> |
> | <span data-ttu-id="aa813-149">`<Foo>`어설션</span><span class="sxs-lookup"><span data-stu-id="aa813-149">`<Foo>`Consumer</span></span> |  | <span data-ttu-id="aa813-150">검색 된 서비스와 상호 작용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-150">Interacts with a service after it has been discovered.</span></span> | <span data-ttu-id="aa813-151">*Proxybusobject* 클래스; *인터페이스 설명* 클래스; *Sessionlistener* 클래스; *Message* 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-151">*ProxyBusObject* class; *InterfaceDescription* class; *SessionListener* class; *Message* class</span></span> |
> | <span data-ttu-id="aa813-152">`<Foo>``<Method>`CalledEventArgs</span><span class="sxs-lookup"><span data-stu-id="aa813-152">`<Foo>``<Method>`CalledEventArgs</span></span> |  | <span data-ttu-id="aa813-153">의 `EventAdapters.<Foo>ServiceEventAdapter`메서드에 전달 된 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-153">Arguments passed to methods in `EventAdapters.<Foo>ServiceEventAdapter`.</span></span> | <span data-ttu-id="aa813-154">*Message* 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-154">*Message* class</span></span> |
> | <span data-ttu-id="aa813-155">`<Foo>``<Method>`만들어집니다</span><span class="sxs-lookup"><span data-stu-id="aa813-155">`<Foo>``<Method>`Result</span></span> |  | <span data-ttu-id="aa813-156">호출의 성공 또는 실패 및<Foo>반환 값을 보고 하기 위해 I 서비스의 메서드 구현에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-156">Used by method implementations in I<Foo>Service to report the success or failure of the call, as well as any return values.</span></span> | <span data-ttu-id="aa813-157">*메시지* 클래스 *Qstatus*</span><span class="sxs-lookup"><span data-stu-id="aa813-157">*Message* class; *QStatus*</span></span> |
> | <span data-ttu-id="aa813-158">`<Foo>``<Signal>`ReceivedEventArgs</span><span class="sxs-lookup"><span data-stu-id="aa813-158">`<Foo>``<Signal>`ReceivedEventArgs</span></span> |  | <span data-ttu-id="aa813-159">신호의 신호 <Foo>에 전달 되는 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-159">Arguments passed to a signal in <Foo>Signals.</span></span> | <span data-ttu-id="aa813-160">*Message* 클래스</span><span class="sxs-lookup"><span data-stu-id="aa813-160">*Message* class</span></span> |


## <a name="build-guide"></a><span data-ttu-id="aa813-161">빌드 가이드</span><span class="sxs-lookup"><span data-stu-id="aa813-161">Build guide</span></span>

#### <a name="creating-the-component"></a><span data-ttu-id="aa813-162">구성 요소 만들기</span><span class="sxs-lookup"><span data-stu-id="aa813-162">Creating the component</span></span>

<span data-ttu-id="aa813-163">생성 된 코드는 XML과 동일한 인터페이스 이름을 공유 하는 구성 요소에 포함 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-163">The generated code needs to be contained in a component that shares the same interface name as the XML.</span></span> <span data-ttu-id="aa813-164">예를 들어 toaster에 대 한 XML이 toaster으로 정의 된 경우에는 런타임 구성 요소를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-164">For example, if the XML for a toaster is defined as com.microsoft.sample.toaster, we would create a runtime component com.microsoft.sample.</span></span> 

<span data-ttu-id="aa813-165">또는 원하는 모든 구성 요소의 이름을 지정할 수 있습니다 (예: fooCodeGenComponent). 그러나 프로젝트 속성 아래의 루트 네임 스페이스를 인터페이스 이름과 동일 하 게 수동으로 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-165">Alternatively, you can name the component whatever you want (e.g. fooCodeGenComponent), but you must manually update the root namespace under the Project properties to be the same as the interface name.</span></span>

> [!TIP]
> <span data-ttu-id="aa813-166">AllJoynCodeGen 도구에서 생성 된 pch .h 파일에서 루트 네임 스페이스를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa813-166">You can find the root namespace in the pch.h file that is generated from the AllJoynCodeGen tool.</span></span>
