---
title: AllJoynCodeGen 개요
author: saraclay
ms.author: saclayt
ms.date: 09/06/17
ms.topic: article
ms.prod: windows-iot
ms.technology: IoT
description: AllJoynCodeGen, AllJoyn 인터페이스를 사용 하 여 전체 Windows 런타임 구성 요소를 생성 하는 코드 생성 도구에 알아봅니다.
keywords: windows iot, AllJoyn
ms.openlocfilehash: c8e9f08c5565c7e4252e1b15858c08402eedb712
ms.sourcegitcommit: ef85ccba54b1118d49554e88768240020ff514b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/11/2019
ms.locfileid: "59513733"
---
> [!NOTE]
> <span data-ttu-id="1809f-104">보관 된 설명서가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-104">You are viewing archived documentation.</span></span> <span data-ttu-id="1809f-105">Windows 10 IoT에서 더 이상 AllJoyn 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-105">AllJoyn is no longer supported by Windows 10 IoT.</span></span> <span data-ttu-id="1809f-106">질문에 대 한 GitHub에서 문제를 제기 하거나 아래 설명에 의견을 남길 하세요.</span><span class="sxs-lookup"><span data-stu-id="1809f-106">For questions, please open an issue on GitHub or leave us feedback in the comments below.</span></span>

# <a name="alljoyncodegen-overview"></a><span data-ttu-id="1809f-107">AllJoynCodeGen 개요</span><span class="sxs-lookup"><span data-stu-id="1809f-107">AllJoynCodeGen Overview</span></span>

<span data-ttu-id="1809f-108">AllJoynCodeGen 사양 또는 장치에서 파생 하는 하나 이상의 AllJoyn 인터페이스에 대 한 XML 설명을 사용 하 여 전체 Windows 런타임 구성 요소를 생성 하는 코드 생성 도구를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-108">We've created a code generation tool, AllJoynCodeGen, that generates a complete Windows Runtime component using an XML description of one or more AllJoyn interfaces derived from a specification or device.</span></span>

<span data-ttu-id="1809f-109">지원 되는 언어에서이 도구에서 생성 된 Windows 런타임 구성 요소를 사용할 수 있습니다 (JS C#, C++/CX 등) 유니버설 Windows SDK에서 사용할 수 있는 Api를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-109">The Windows Runtime component generated by this tool can be consumed in any supported language (JS, C#, C++/CX, etc.) using APIs that are available in the Universal Windows SDK.</span></span> <span data-ttu-id="1809f-110">즉, 동일한 구성 요소 (라우터 서비스와 C API dll) AllJoyn OneCore 패키지가 포함 된 모든 플랫폼에서 사용할 수 있도록 개발자 구성 요소 사용 하 여 생산자 및/또는 해당 인터페이스의 소비자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-110">This means that the same component can be used on any platform that has the AllJoyn OneCore package (router service and C API dll.) A developer can then use the component to create a producer and/or a consumer of that interface.</span></span> 

<span data-ttu-id="1809f-111">**참고** AllJoyn C Api에 대 한 자세한 내용은 AllJoyn Core SDK 및 설명서를 다운로드할 수 있습니다 [The AllSeen Alliance](http://go.microsoft.com/fwlink/?LinkId=524584)합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-111">**Note**  For more details about the AllJoyn C APIs, you can download the AllJoyn Core SDK and documentation at [The AllSeen Alliance](http://go.microsoft.com/fwlink/?LinkId=524584).</span></span>

## <a name="how-does-alljoyncodegen-work"></a><span data-ttu-id="1809f-112">AllJoynCodeGen는 어떻게 작동 하나요?</span><span class="sxs-lookup"><span data-stu-id="1809f-112">How does AllJoynCodeGen work?</span></span>

<span data-ttu-id="1809f-113">기본 흐름은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-113">The basic flow is as follows:</span></span>

1. <span data-ttu-id="1809f-114">서비스를 설명 하는 AllJoyn XML (현재 Dbu 검사 형식)에서 작성 된 XML 파일 codegen 도구에 공급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-114">An XML file authored in the AllJoyn XML (currently DBus introspection format) that describes the service is fed into the codegen tool.</span></span>
2. <span data-ttu-id="1809f-115">AllJoynCodeGen 도구는 Windows 런타임 구성 요소에서 발생 하는 코드를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-115">The AllJoynCodeGen tool generates code that results in a Windows Runtime component.</span></span> <span data-ttu-id="1809f-116">이 생성 된 코드에 의존 **MSAJAPI.lib** 하 고 [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx) Windows 10 SDK에서.</span><span class="sxs-lookup"><span data-stu-id="1809f-116">This generated code relies on **MSAJAPI.lib** and [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.alljoyn.aspx) from the Windows 10 SDK.</span></span>
3. <span data-ttu-id="1809f-117">개발자는이 구성 요소를 사용 하는 응용 프로그램을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-117">The developer builds an application that consumes this component.</span></span>
4. <span data-ttu-id="1809f-118">런타임 시 응용 프로그램 개발자의 도구로 생성 되 고 Windows 런타임 구성 요소 로드 됩니다 (예:: 이어야 합니다) 상자에서 Dll 뿐만 아니라 **MSAJAPI.dll** 하 고 **Windows.Devices.AllJoyn.dll**합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-118">At runtime, the developer's application will load the Windows Runtime component generated by the tool (e.g.: foo.dll,) as well as the in-box DLLs **MSAJAPI.dll** and **Windows.Devices.AllJoyn.dll**.</span></span>

<span data-ttu-id="1809f-119">다음 워크플로 다이어그램에서는이 프로세스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-119">The following workflow diagram illustrates this process:</span></span>

![AllJoyn CodeGen 다이어그램](../media/AllJoyn/alljoyncodegen.png)

## <a name="running-from-the-command-line"></a><span data-ttu-id="1809f-121">명령줄에서 실행</span><span class="sxs-lookup"><span data-stu-id="1809f-121">Running from the command line</span></span>

<span data-ttu-id="1809f-122">AllJoynCodeGen 도구는 현재 Windows 10 SDK와 함께 제공 되는 명령줄 도구로 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-122">The AllJoynCodeGen tool currently exists as a command line tool shipped with the Windows 10 SDK.</span></span> <span data-ttu-id="1809f-123">실행 하려면 도구는 다음 문자열을 사용 하는 유효한 XML 파일을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-123">To run the tool pass a valid XML file using the following string:</span></span>

    AllJoynCodeGen –i Foo.xml –o c:\users\developer1\documents\Foo\

## <a name="reviewing-the-output"></a><span data-ttu-id="1809f-124">출력 검토</span><span class="sxs-lookup"><span data-stu-id="1809f-124">Reviewing the output</span></span>

<span data-ttu-id="1809f-125">생성된 된 클래스는 핵심 C API에서 노출 하는 기능을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-125">The generated classes wrap functionality exposed by the Core C API.</span></span> <span data-ttu-id="1809f-126">생성된 된 코드 추상적 이기 때문에 이것이-1-1 매핑이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-126">Because the generated code is an abstraction, this is not a 1-to-1 mapping.</span></span> <span data-ttu-id="1809f-127">아래 표에 나와 있는 Core C++ Api는 각 생성 된 코드 클래스에 의해 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-127">The table below shows which Core C++ APIs are wrapped by each generated code class.</span></span> <span data-ttu-id="1809f-128">다음 자리 표시자의 테이블에 생성 된 이름에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-128">The following placeholders are used for generated names in the table:</span></span>

* `<Foo>` <span data-ttu-id="1809f-129">xml 파일에 정의 된 인터페이스의 이름</span><span class="sxs-lookup"><span data-stu-id="1809f-129">is the name of the interface defined in the xml file</span></span>
* `<Signal>` <span data-ttu-id="1809f-130">xml 파일에서 가져온 신호를의 이름인</span><span class="sxs-lookup"><span data-stu-id="1809f-130">is the name of a signal, taken from the xml file</span></span>
* `<Method>` <span data-ttu-id="1809f-131">xml 파일에서 가져온 메서드의 이름</span><span class="sxs-lookup"><span data-stu-id="1809f-131">is the name of a method, taken from the xml file</span></span>
* `<Property>` <span data-ttu-id="1809f-132">xml 파일에서 수행 되는 속성의 이름</span><span class="sxs-lookup"><span data-stu-id="1809f-132">is the name of a property, taken from the xml file</span></span>


> | <span data-ttu-id="1809f-133">Windows 런타임 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-133">Windows Runtime Class</span></span> |  | <span data-ttu-id="1809f-134">설명</span><span class="sxs-lookup"><span data-stu-id="1809f-134">Description</span></span> | <span data-ttu-id="1809f-135">핵심 C++ API</span><span class="sxs-lookup"><span data-stu-id="1809f-135">Core C++ API</span></span> |
> | ------------------------ | --- | --------- | ---------- |
> | `<Foo>`<span data-ttu-id="1809f-136">감시자</span><span class="sxs-lookup"><span data-stu-id="1809f-136">Watcher</span></span> |  | <span data-ttu-id="1809f-137">대상 서비스를 보급 하는 생산자에 대 한 검색</span><span class="sxs-lookup"><span data-stu-id="1809f-137">Searches for producers that advertise the target service</span></span> | <span data-ttu-id="1809f-138">*BusListener* 클래스 *BusAttachment* 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-138">*BusListener* class; *BusAttachment* class</span></span> |
> | `<Foo>`<span data-ttu-id="1809f-139">JoinSessionResult</span><span class="sxs-lookup"><span data-stu-id="1809f-139">JoinSessionResult</span></span> |  | <span data-ttu-id="1809f-140">세션에 참가의 성공 여부를 보고 하 고 노출 된 `<Foo>Consumer` 성공적으로 조인 하는 경우 세션에 대 한 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="1809f-140">Reports the success or failure of joining a session, and exposes a `<Foo>Consumer` instance for the session if the join was successful.</span></span> | <span data-ttu-id="1809f-141">*JoinSessionAsyncCB* class; *QStatus*</span><span class="sxs-lookup"><span data-stu-id="1809f-141">*JoinSessionAsyncCB* class; *QStatus*</span></span> |
> | `<Foo>`<span data-ttu-id="1809f-142">생산자</span><span class="sxs-lookup"><span data-stu-id="1809f-142">Producer</span></span> |  | <span data-ttu-id="1809f-143">서비스를 보급 하 고 AllJoyn 이벤트에 대 한 처리기를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-143">Advertises a service and exposes handlers for AllJoyn events.</span></span> | <span data-ttu-id="1809f-144">*BusObject* 클래스 *BusAttachment* 클래스 *InterfaceDescription* 클래스 *SessionPortListener* 클래스 *메시지* 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-144">*BusObject* class; *BusAttachment* class; *InterfaceDescription* class; *SessionPortListener* class; *Message* class</span></span> |
> | `<Foo>`<span data-ttu-id="1809f-145">신호</span><span class="sxs-lookup"><span data-stu-id="1809f-145">Signals</span></span> |  | <span data-ttu-id="1809f-146">메서드 및 신호를 수신 하는 처리기를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-146">Exposes methods and handlers to send and receive signals.</span></span> <span data-ttu-id="1809f-147">생산자와 소비자 모두가 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-147">Used by both producers and consumers.</span></span> | <span data-ttu-id="1809f-148">*BusObject* 클래스 *InterfaceDescription* 클래스 *메시지* 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-148">*BusObject* class; *InterfaceDescription* class; *Message* class</span></span> |
> | `<Foo>`<span data-ttu-id="1809f-149">소비자</span><span class="sxs-lookup"><span data-stu-id="1809f-149">Consumer</span></span> |  | <span data-ttu-id="1809f-150">검색 후 서비스와 상호 작용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-150">Interacts with a service after it has been discovered.</span></span> | <span data-ttu-id="1809f-151">*ProxyBusObject* 클래스 *InterfaceDescription* 클래스 *SessionListener* 클래스 *메시지* 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-151">*ProxyBusObject* class; *InterfaceDescription* class; *SessionListener* class; *Message* class</span></span> |
> | `<Foo>``<Method>`<span data-ttu-id="1809f-152">CalledEventArgs</span><span class="sxs-lookup"><span data-stu-id="1809f-152">CalledEventArgs</span></span> |  | <span data-ttu-id="1809f-153">메서드에 전달 된 인수 `EventAdapters.<Foo>ServiceEventAdapter`합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-153">Arguments passed to methods in `EventAdapters.<Foo>ServiceEventAdapter`.</span></span> | <span data-ttu-id="1809f-154">*메시지* 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-154">*Message* class</span></span> |
> | `<Foo>``<Method>`<span data-ttu-id="1809f-155">결과</span><span class="sxs-lookup"><span data-stu-id="1809f-155">Result</span></span> |  | <span data-ttu-id="1809f-156">I에서 메서드 구현에서 사용 하는<Foo>모든 값을 반환 하는 것은 물론 호출의 성공 여부를 보고 하는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-156">Used by method implementations in I<Foo>Service to report the success or failure of the call, as well as any return values.</span></span> | <span data-ttu-id="1809f-157">*메시지* 클래스 *QStatus*</span><span class="sxs-lookup"><span data-stu-id="1809f-157">*Message* class; *QStatus*</span></span> |
> | `<Foo>``<Signal>`<span data-ttu-id="1809f-158">ReceivedEventArgs</span><span class="sxs-lookup"><span data-stu-id="1809f-158">ReceivedEventArgs</span></span> |  | <span data-ttu-id="1809f-159">인수에서 신호를 전달할 <Foo>신호입니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-159">Arguments passed to a signal in <Foo>Signals.</span></span> | <span data-ttu-id="1809f-160">*메시지* 클래스</span><span class="sxs-lookup"><span data-stu-id="1809f-160">*Message* class</span></span> |


## <a name="build-guide"></a><span data-ttu-id="1809f-161">빌드 가이드</span><span class="sxs-lookup"><span data-stu-id="1809f-161">Build guide</span></span>

#### <a name="creating-the-component"></a><span data-ttu-id="1809f-162">구성 요소 만들기</span><span class="sxs-lookup"><span data-stu-id="1809f-162">Creating the component</span></span>

<span data-ttu-id="1809f-163">생성 된 코드를 XML로 동일한 인터페이스 이름을 공유 하는 구성 요소에 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-163">The generated code needs to be contained in a component that shares the same interface name as the XML.</span></span> <span data-ttu-id="1809f-164">예를 들어는 토스터에 대 한 XML com.microsoft.sample.toaster로 정의 된 경우 런타임 구성 요소 com.microsoft.sample를 만듭니다 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-164">For example, if the XML for a toaster is defined as com.microsoft.sample.toaster, we would create a runtime component com.microsoft.sample.</span></span> 

<span data-ttu-id="1809f-165">또는 모든 구성 요소 이름을 지정할 수 있습니다 (예: fooCodeGenComponent) 싶지만 인터페이스 이름이 동일 하도록 프로젝트 속성에서 루트 네임 스페이스를 수동으로 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-165">Alternatively, you can name the component whatever you want (e.g. fooCodeGenComponent), but you must manually update the root namespace under the Project properties to be the same as the interface name.</span></span>

> [!TIP]
> <span data-ttu-id="1809f-166">AllJoynCodeGen 도구에서 생성 되는 pch.h 파일의 루트 네임 스페이스를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1809f-166">You can find the root namespace in the pch.h file that is generated from the AllJoynCodeGen tool.</span></span>
